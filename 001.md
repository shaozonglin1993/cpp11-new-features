# 新类型
>C++11新增的类型 long long和unsigned long long，以支持64位（或更宽）的整形。新增了类型char16_t和char_32_t,以支持16位和32位的字符表示。还新增了“原始”字符串。  
>这里解释什么是“原始”字符串? 
>所谓原始字符串(raw string)就是字符表示的就是自己，引号和斜杠均无需\进行转义，这在需要输出很多引号和斜杠代码中很方便。  
>C++11原始字符串同时包含其它特点：  
>字符串中的换行符将在屏幕上如实显示。  
>在表示字符串开头的"和(之间可以添加其它字符，不过必须在表示字符串结尾的)和"之间添加同样的字符。  
>第二个特性允许在字符串中使用任何和原始字符串边界标识不同的任意字符组合，而不用担心提前结束原始字符串，比如使用“)。  
“原始”字符串参考《C++Primer Plus》中文版第六版4.3.5节(p.87)
# 统一的初始化
>C++11扩大了用大括号括起来的列表（初始化列表）的适用范围。使其可用于所有那只类型和用户自定义类型（即类对象）。使用初始化列表时，可添加符等号（=），也可以不添加。  
>
>```c++
>int x = { 5 };
>double y { 2.75 };
>short quar[5] { 4, 5, 2, 76, 1 };
>```
>
>另外，初始化列表语法也可以用于new表达式中：  
>
>```c++
>int arr = new int[4] { 2, 4, 6, 7 };
>```

> 创建对象，可以使用大括号（而不是圆括号）括起来的列表来调用构造函数；
>
> ```c++
> string s1("abc");
> string s2{ "abc" };
> string s3 = { "abc" };
> ```
>
> **1、缩窄**
>
> 初始化列表可以防止缩窄（禁止将数值赋给无法储存他的数值变量），例如
>
> 无意义的操作：
>
> ```c++
> char ch1 = 1.57e27; //double to char `
> char ch2 = 459232; //int to char`
> ```
>
> 但是，如果使用初始化列表，编译器将禁止进行以上无意义的操作：
>
> ```c++
> char ch1 {1.57e27}; //double to char, 编译时报错`
> char ch2 = {459232}; //int to char, 编译时错误`
> ```
>
> 但是，允许转换为更宽的类型：
>
> ```c++
> char ch1{66}; //int to char, 66在char的范围内，允许`
> bouble b = {66}; //int to double,允许`
> ```
>
> **2、std::initializer_list**
>
> C++11提供了模板类initializer_list，可将其用作构造函数的参数（该模板类是什么暂不研究）。如果类有接受initializer_list作为参数的构造函数，则初始化列表语法就只能用于该构造函数。列表中的元素必须是同一种类型或可转换为同一种类型。STL容器提供了将**initializer_list**作为参数的构造函数：
>
> ```c++
> vector<int> v1(10); //未初始化的含有10个元素的vector`
> vector<int> v2{10}; //含有一个初始化为10元素的vector`
> vector<int> v3{4, 6, 1}; //三个元素分别初始化为4，6，1`
> ```
>
> **栗子：**
>
> 头文件initializer_list提供了对模板类initializer_list的支持。这个类包含成员函数begin()和end()，可用于获悉列表的范围。出用于构造函数外，还可以将initializer_list用作常规函数的参数：
>
> ```c++
> #include <initializer_list>
> 
> double sum(std::initializer_list<double> i);
> int main()
> {
>     double t = sum(2.5, 3.1, 4);
>     ...
> }
> 
> double sum(std::initializer_list<double> i)
> 
> {
>     double tot = 0;
>     for(auto p = i.begin(); p != i.end(); p++)
>         tot += *p;
>     return tot;
> }
> ```

# 声明

C++11提供了多种简化声明的方式，尤其在使用模板时。

1、auto

> 声明变量，变量的类型跟随初始化的值类型。
>
> 简化模板声明：
>
> ```c++
> for(std::initializer_list<double>::iterator p = i.begin(); p != i.end(); p++)
> {}
> ```
>
> 可以替换为：
>
> ```c++
> for(auto p = i.begin(); p != i.end(); p++)
> {}
> ```

2、decltype

> 将变量的类型声明为表达式指定的类型。
>
> 举个例子：
>
> ```c++
> decltype(x) y; //让y的类型与x相同。
> ```
>
> 在举个栗子：
>
> ```c++
> double x;
> int n;
> decltype(x*n) q;  //q -- double
> decltype(&x) pd;  //pd - double*
> ```
>
> 他的作用是什么？
>
> 定义模板时很有用，因为只有等到模板实例化时才能确定类型：
>
> ```c++
> template<typename T, typename U>
> void ef(T t, U u)
> {
>     decltype(T*U) tu;
> }
> ```
>
> decltype比auto要复杂多，根据使用的表达式，指定的类型可以为引用和const。
>
> 据几个栗子：
>
> ```c++
> int j = 3;
> int &k = j;
> const int &n = j;
> decltype(n) i1; //const int &
> decltype(j) i2; //int
> decltype((j)) i3; //int &
> decltype(k+1) i4; //int
> ```
>
> 







